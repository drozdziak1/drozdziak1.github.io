---
layout: post
title: "DSP-17 #3: \"Say hello to my little friend\" - writing a \"Hello,
World!\" kernel module for Linux"
author: Stan Drozd
date: 2017-03-18 10:00:00 +0100
categories: dsp17
excerpt: "I failed to think of a penguin metaphore, Scarface will have to do"
tags: dsp17 tutorial kernel modules c compilation
---
Linux is capable of many interesting things, and loadable module functionality
is one of them. Linux kernel modules are just pieces of binary that can get
linked on-the-fly against a running kernel. This approach is especially nice
for speeding up your code-compile-run cycle and in systems that frown upon
downtimes.  Today, we're going to harness that power and write a module that
will print two messages on module load and unload, respectively.

# Prerequisites
* **A (virtual) machine running Linux** - If you're already running Linux the VM
  is optional, as it's hard to break anything with this particular module
* **Basic understanding of C and simple GNU Makefiles** - There's finally gonna
  be C code involved; to build our module we'll use a simple ,

# Coding style
Before writing any code it's important to mention *how* to write it. Some
of the most important kernel rules involve:
* **8-space-wide tabs** - Most programmers would probably expect 4 spaces for
  indentation, with Linux we're using actual tab characters set in your editor
to the width of 8 spaces; Vim users 
* **80 column width limit** (with exceptions if a longerline is really worth it)
* **When in doubt, comply with K&R** - When Brian W. Kernighan and Dennis Ritchie
  wrote **"The C programming language"** (a.k.a. **K&R**), they also established a robust standard
  for C coding style. In fact, Linux could be thought of as a subset of the K&R
  style 

# The code
Consider the following:

```c
#include <linux/module.h> /* Needed by all modules */
#include <linux/kernel.h> /* For KERN_INFO */

int __init hello_init(void)
{
        printk(KERN_INFO "Hello, world!\n");

        return 0;
}

void __exit hello_exit(void)
{
        printk(KERN_INFO "Goodbye, world!\n");

        return;
}

module_init(hello_init);
module_exit(hello_exit);

MODULE_DESCRIPTION("My \"Hello, World!\" module");
MODULE_AUTHOR("Stan Drozd <drozdziak1@gmail.com>");
MODULE_LICENSE("GPL"); /* Certain licenses taint the kernel */

```

Let's talk about what the code above means.

`hello_init` is our module's init function - it'll make all preparations
necessary to get our module ready to do its job (in our case we only want to
greet the globe). Init functions are usually called only once on module load.
The `__init` attribute tells your kernel to free the memory `hello_init` was
occupying.

`hello_exit` on the other hand cares about everything that has to do with
cleaning up after your module when you unload it.

# The build
* Present the basic Makefile


# In-tree build

# Out-of-tree build (against the running kernel?)

# Lodaing and unloading of kernel modules
* insmod/rmmod
* modprobe
* lsmod

# Further reading
* [Documentation/process/coding-style.rst][coding-style] - The full kernel
  coding style documentation
* [Documentation/kbuild/modules.txt][kbuild-modules] - More on kernel modules
* [include/linux/init.h][linux-init-h] - More on `__init` and `__exit`

[coding-style]:http://lxr.free-electrons.com/source/Documentation/process/coding-style.rst
[dsp-1]:{% post_url 2017-03-02-DSP17-1-the-kernel-role-in-OS %}
[kbuild-modules]:http://lxr.free-electrons.com/source/Documentation/kbuild/modules.txt
