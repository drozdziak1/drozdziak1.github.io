---
layout: post
title:  "DSP-17 #1: The kernel's role in an OS"
author: Stan Drozd
date: 2017-02-28 19:00:00 +0100
categories: dsp17
tags: kernel introduction anatomy tux penguin compilation dsp17
---
![Hey kids, wanna recompile some kernels?]({{ site.url }}/assets/recompile_some_kernels.jpg)
# So... you wanna do some Kernel Hacking?
If your answer (to both questions, preferably) is "yes" then you're probably in
the right place. But before we do anything, we'd better find out what it is that
we want to hack.

# What the hell is a kernel?
There's a couple definitions we could put up with, but most prominently, a
kernel is the centerpiece of every OS, it's the program that has the ultimate
control over all hardware and software present in a system. It uses this power
to provide a whole array of functionalities vital for an operating system to...
operate.

If we were to bake a cake from all things that make a computer work, we'd find
our kernel in the second layer - that sour jam supporting all the fluffy
software cream, covering its crusty bottom - the hardware, if you will
:upside_down_face:. If your OS was a country's government, the kernel would be
the president.

# What does it do, again?
My definition may sound a bit vague, but that's because kernels come in various
shapes and sizes - and so do their responsibilities. Typically, a kernel
supplies everything above it with things like process scheduling, memory
management, device drivers or access to filesystems, but depending on a kernel's
design, the span of its jurisdiction might be something more... or less!

When your machine is running, all the higher level, "regular" software governed
by your kernel does its thing in a place called **userspace**. Surprise,
surprise - on the other hand, the environment in which the kernel executes is
called **kernelspace**. Working with kernel code usually requires the programmer
to bear a couple things in mind:
* **The kernel code is  mostly allergic to floating point operations** - it's
  actually one of a kernel's tasks to deal with floating point numbers, and with
  each such number, the kernel has to pass it to an **FPU** (FPUs are secondary
  processors specialized in floating-point arithmetics), a similar facility (like
  Intel's SSE CPU extensions) or emulate the operation entirely (expensive!
  :money_with_wings:). It's not a big problem though, most use cases for
  floating-point can be avoided by designating some bits in an integer to the
  decimal part, which is what a lot of hardware does anyway.
* **The kernel code has to be bulletproof** - one critical error (like a
  segmentation fault) in the kernel is enough to compromise the whole system and
  force the user to reboot their machine. Not much of a desired outcome on a
  server, right?
* **Backdoors are lethal**

Some of the most popular kernel types involve **microkernels**, **monolithic**
kernels and **library** kernels.

# What's the difference?
Apart from the differences in implementation of their features, the three breeds
of kernels mainly diverge in how much they actually *do* on behalf of userland.

# Microkernel
A microkernel generally aims to push all responsibility out of the kernelspace


## Penguin Anatomy 101 :penguin: :skull: :mag:
Linux, falling into the monolithic kernel category
